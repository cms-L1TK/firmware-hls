#!/usr/bin/env python3

# This script generates TrackBuilderTop.h and TrackBuilderTop.cc in the
# TopFunctions/ directory.

from __future__ import absolute_import
import os
import re
import argparse
from enum import Enum

class ITC(Enum):
    A = 0
    B = 1
    C = 2
    D = 3
    E = 4
    F = 5
    G = 6
    H = 7
    I = 8
    J = 9
    K = 10
    L = 11
    M = 12
    N = 13
    O = 14
    P = 15
    Q = 16
    R = 17
    S = 18
    T = 19
    U = 20
    V = 21
    W = 22
    X = 23
    Y = 24
    Z = 25

memNameLength = [
    len("MPAR_L1L2X"),    # one page
    len("MPAR_L1L2XX"),   # two pages
    len("MPAR_L1L2XXX"),  # three pages
    len("MPAR_L1L2XXXX"), # four pages
]

parser = argparse.ArgumentParser(description="This script generates TrackBuilderTop.h and TrackBuilderTop.cc in the\
TopFunctions/ directory.",
                                 epilog="")
parser.add_argument("-o", "--outputDirectory", metavar="DIR", default="../TopFunctions/", type=str, help="The directory in which to write the output files for the TB (default=%(default)s)")
parser.add_argument("-w", "--wiresFileName", metavar="WIRES_FILE", default="LUTs/wires.dat", type=str, help="Name and directory of the configuration file for wiring for the TB (default = %(default)s)")
parser.add_argument("-sp", "--split", action='store_true', help="Split project so use MPAR not TPAR")
arguments = parser.parse_args()

# Keep in sync with
# kTProjITCSize in TrackletAlgorithm/TrackletProjectionMemory.h and
# kFMITCSize in TrackletAlgorithm/FullMatchMemory.h

# First, parse the wires file and store the memory names associated with TBs in
# dictionaries with the TB names as keys.
with open(arguments.wiresFileName, "r") as wiresFile:
    tparMems = {}
    barrelFMMems = {}
    diskFMMems = {}
    for line in wiresFile:
        if " TB_" not in line:
            continue
        line = line.rstrip()
        tbName = re.sub(r".*TB_(....).*", r"TB_\1", line)
        seed = tbName.split("_")[1]
        memName = line.split()[0]
        partype = "TPAR"
        if arguments.split:
            partype = "MPAR"
        if memName.startswith(partype):
            if tbName not in tparMems:
                tparMems[tbName] = []
            tparMems[tbName].append(memName)
        if memName.startswith("FM"):
            if tbName not in barrelFMMems:
                barrelFMMems[tbName] = []
            if tbName not in diskFMMems:
                diskFMMems[tbName] = []
            if memName.startswith("FM_" + seed + "_L"):
                barrelFMMems[tbName].append(memName)
            if memName.startswith("FM_" + seed + "_D"):
                diskFMMems[tbName].append(memName)

# Open and print out preambles for the top files.
dirname = os.path.dirname(os.path.realpath('__file__'))
with open(os.path.join(dirname, arguments.outputDirectory, "TrackBuilderTop.h"), "w") as topHeaderFile, \
     open(os.path.join(dirname, arguments.outputDirectory, "TrackBuilderTop.cc"), "w") as topFile, \
     open(os.path.join(dirname, arguments.outputDirectory, "TrackBuilder_parameters.h"), "w") as parameterFile:
    topHeaderFile.write(
        "#ifndef TopFunctions_TrackBuilderTop_h\n"
        "#define TopFunctions_TrackBuilderTop_h\n"
        "\n"
        "#include \"TrackletParameterMemory.h\"\n"
        "#include \"FullMatchMemory.h\"\n"
        "#include \"TrackFitMemory.h\"\n"
    )
    topFile.write(
        "#include \"TrackBuilderTop.h\"\n"
        "#include \"TrackBuilder.h\"\n"
    )
    parameterFile.write(
        "#ifndef TopFunctions_TrackBuilder_parameters_h\n"
        "#define TopFunctions_TrackBuilder_parameters_h\n"
        "\n"
        "#include \"FullMatchMemory.h\"\n"
        "static const unsigned short kNBitsITC = FullMatchBase<BARREL>::kFMITCSize;\n"
        "typedef ap_uint<kNBitsITC> ITCType;\n"
        "\n"
        "// Hardcoded parameters from the wiring.\n"
        "// Generated by generate_TB.py\n\n"

        "template<TF::seed Seed> constexpr int getNumTParMem();\n"
        "template<TF::seed Seed> constexpr int getNumBarrelFMMem();\n"
        "template<TF::seed Seed> constexpr int getNumDiskFMMem();\n"
        "template<TF::seed Seed> constexpr int getNumBarrelFMMemPerStub0();\n"
        "template<TF::seed Seed> constexpr int getNumBarrelFMMemPerStub();\n"
        "template<TF::seed Seed> constexpr int getNumDiskFMMemPerStub();\n"
        "template<TF::seed Seed> constexpr int getNumBarrelStub();\n"
        "template<TF::seed Seed> constexpr int getNumDiskStub();\n"
        "template<TF::seed Seed> inline    int getMPARNPages(const ITCType &);\n"
        "template<TF::seed Seed> inline    int getMPARMem(const ITCType &);\n"
        "template<TF::seed Seed> inline    int getMPARPage(const ITCType &);\n"
    )

    # Calculate parameters and print out top function for each TB.
    for tbName in sorted(tparMems.keys()):
        seed = re.sub(r"TB_(....)", r"\1", tbName)
        seedNumber = None
        if seed == "L1L2":
            seedNumber = 0
        elif seed == "L2L3":
            seedNumber = 1
        elif seed == "L3L4":
            seedNumber = 2
        elif seed == "L5L6":
            seedNumber = 3
        elif seed == "D1D2":
            seedNumber = 4
        elif seed == "D3D4":
            seedNumber = 5
        elif seed == "L1D1":
            seedNumber = 6
        elif seed == "L2D1":
            seedNumber = 7

        # numbers of memories
        nTPARMem = []
        for i in range(0, 4):
            nTPARMem.append(len([tpar for tpar in tparMems[tbName] if len(tpar) == memNameLength[i]]))
        nBarrelFMMem = len(barrelFMMems[tbName])
        nDiskFMMem = len(diskFMMems[tbName])

        # numbers of output stubs
        barrelFMs = sorted([fm[0:10] for fm in barrelFMMems[tbName]])
        diskFMs = sorted([fm[0:10] for fm in diskFMMems[tbName]])
        nBarrelStubs = len(set(barrelFMs))
        nDiskStubs = len({fm[0:10] for fm in diskFMMems[tbName]})

        # numbers of memories per stub
        layercount = {}
        for fm in barrelFMs :
            if fm not in layercount:
                layercount[fm]=0
            layercount[fm]+=1
        nFMBarrel=0
        for layer, count in layercount.items():
            shift=int(layer[-1])-1
            nFMBarrel+=(count<<(4*shift))

        diskcount = {}
        for fm in diskFMs :
            if fm not in diskcount:
                diskcount[fm]=0
            diskcount[fm]+=1
        nFMDisk=0
        for disk, count in diskcount.items():
            shift=int(disk[-1])-1
            nFMDisk+=(count<<(4*shift))

        barrelFM0 = barrelFMs[0] if len(barrelFMs) > 0 else ""
        nBarrelFMMemPerStub0 = barrelFMs.count(barrelFM0)
        barrelFMs = [fm for fm in barrelFMs if fm != barrelFM0]
        nBarrelFMMemPerStub = int(len(barrelFMs) / (nBarrelStubs - 1)) if nBarrelStubs > 1 else 0
        nDiskFMMemPerStub = int(nDiskFMMem / nDiskStubs) if nDiskStubs > 0 else 0

        # mask for enabling/disabling arrays of TPAR memories
        tparMask = 0
        for i in range(0, 4):
            if nTPARMem[i] > 0:
                tparMask = tparMask | (1 << i)

        # definition of getMPARNPages function
        nParentheses = 0
        first = True
        maxNPages = max([len(tpar) - len("MPAR_L1L2") for tpar in tparMems[tbName]])
        getMPARNPages = "template<> inline int\n"
        getMPARNPages += "getMPARNPages<TF::" + seed + ">(const ITCType &iTC) {\n"
        getMPARNPages += "  return "
        for i in range(1, maxNPages):
            if nTPARMem[i - 1] == 0:
                continue
            if not first:
                getMPARNPages += "(\n         "
                nParentheses += 1
            mems = [tpar for tpar in tparMems[tbName] if len(tpar) == memNameLength[i - 1]]
            pages = "".join([tpar[9:] for tpar in mems])
            pages = [ITC[page].value for page in pages]
            getMPARNPages += "(iTC == " + str(pages[0])
            for page in pages[1:]:
                getMPARNPages += " || iTC == " + str(page)
            getMPARNPages += ") ? " + str(i) + " : "
            first = False
        getMPARNPages += str(maxNPages)
        for i in range(0, nParentheses):
            getMPARNPages += ")"
        getMPARNPages += ";\n}\n"

        # definition of getMPARMem function
        nParentheses = 0
        getMPARMem = "template<> inline int\n"
        getMPARMem += "getMPARMem<TF::" + seed + ">(const ITCType &iTC) {\n"
        getMPARMem += "  return "
        for i in range(0, max(nTPARMem) - 1):
            if i != 0:
                getMPARMem += "(\n         "
                nParentheses += 1
            mems = []
            for j in range(0, 4):
                allMems = [tpar for tpar in tparMems[tbName] if len(tpar) == memNameLength[j]]
                if len(allMems) > i:
                    mems.append(allMems[i])
            pages = "".join([tpar[9:] for tpar in mems])
            pages = [ITC[page].value for page in pages]
            getMPARMem += "(iTC == " + str(pages[0])
            for page in pages[1:]:
                getMPARMem += " || iTC == " + str(page)
            getMPARMem += ") ? " + str(i) + " : "
        getMPARMem += str(max(nTPARMem) - 1)
        for i in range(0, nParentheses):
            getMPARMem += ")"
        getMPARMem += ";\n}\n"

        # definition of getMPARPage function
        nParentheses = 0
        getMPARPage = "template<> inline int\n"
        getMPARPage += "getMPARPage<TF::" + seed + ">(const ITCType &iTC) {\n"
        getMPARPage += "  return "
        for i in range(0, maxNPages - 1):
            if i != 0:
                getMPARPage += "(\n         "
                nParentheses += 1
            pages = "".join([tpar[9 + i] for tpar in tparMems[tbName] if len(tpar) > 9 + i])
            pages = [ITC[page].value for page in pages]
            getMPARPage += "(iTC == " + str(pages[0])
            for page in pages[1:]:
                getMPARPage += " || iTC == " + str(page)
            getMPARPage += ") ? " + str(i) + " : "
        getMPARPage += str(maxNPages - 1)
        for i in range(0, nParentheses):
            getMPARPage += ")"
        getMPARPage += ";\n}\n"

        # Print out prototype for top function for this TB.
        topHeaderFile.write(
            "\n"
            "void TrackBuilder_" + seed + "(\n"
            "    const BXType bx,\n"
            "    const TrackletParameterMemory1 trackletParameters1[],\n"
            "    const TrackletParameterMemory2 trackletParameters2[],\n"
            "    const TrackletParameterMemory3 trackletParameters3[],\n"
            "    const TrackletParameterMemory4 trackletParameters4[],\n"
            "    const FullMatchMemory<BARREL> barrelFullMatches[],\n"
            "    const FullMatchMemory<DISK> diskFullMatches[],\n"
            "    BXType &bx_o,\n"
            "    TrackFit<trklet::N_LAYER, trklet::N_DISK>::TrackWord trackWord[],\n"
            "    TrackFit<trklet::N_LAYER, trklet::N_DISK>::BarrelStubWord barrelStubWords[][kMaxProc()],\n"
            "    TrackFit<trklet::N_LAYER, trklet::N_DISK>::DiskStubWord diskStubWords[][kMaxProc()],\n"
            "    bool &done\n"
            ");\n"
        )

        # Print out prototype for top function for this TB.
        parameterFile.write(
            "\n"
             "\n////////////////\n// " + seed + " //\n////////////////\n"
             "template<> constexpr int getNumTParMem<TF::" + seed + ">(){ // Number of input tpar mem\n"
                "  return " + str(sum(nTPARMem)) + ";\n"
             "}\n"
             "template<> constexpr int getNumBarrelFMMem<TF::" + seed + ">(){ \n"
                "  return " + str(nBarrelFMMem) + ";\n"
             "}\n"
             "template<> constexpr int getNumDiskFMMem<TF::" + seed + ">(){ \n"
                "  return " + str(nDiskFMMem) + ";\n"
             "}\n"
             "template<> constexpr int getNumBarrelFMMemPerStub0<TF::" + seed + ">(){ \n"
                "  return " + str(nBarrelFMMemPerStub0) + ";\n"
             "}\n"
             "template<> constexpr int getNumBarrelFMMemPerStub<TF::" + seed + ">(){ \n"
                "  return " + str(nBarrelFMMemPerStub) + ";\n"
             "}\n"
             "template<> constexpr int getNumDiskFMMemPerStub<TF::" + seed + ">(){ \n"
                "  return " + str(nDiskFMMemPerStub) + ";\n"
             "}\n"
             "template<> constexpr int getNumBarrelStub<TF::" + seed + ">(){ \n"
                "  return " + str(nBarrelStubs) + ";\n"
             "}\n"
             "template<> constexpr int getNumDiskStub<TF::" + seed + ">(){ \n"
                "  return " + str(nDiskStubs) + ";\n"
             "}\n"+
             getMPARNPages+
             getMPARMem+
             getMPARPage
        )

        # Print out definition of top function for this TB.
        topFile.write(
            "\n"
            "void TrackBuilder_" + seed + "(\n"
            "    const BXType bx,\n"
            "    const TrackletParameterMemory1 trackletParameters1[" + str(nTPARMem[0]) + "],\n"
            "    const TrackletParameterMemory2 trackletParameters2[" + str(nTPARMem[1]) + "],\n"
            "    const TrackletParameterMemory3 trackletParameters3[" + str(nTPARMem[2]) + "],\n"
            "    const TrackletParameterMemory4 trackletParameters4[" + str(nTPARMem[3]) + "],\n"
            "    const FullMatchMemory<BARREL> barrelFullMatches[" + str(nBarrelFMMem) + "],\n"
            "    const FullMatchMemory<DISK> diskFullMatches[" + str(nDiskFMMem) + "],\n"
            "    BXType &bx_o,\n"
            "    TrackFit<trklet::N_LAYER, trklet::N_DISK>::TrackWord trackWord[kMaxProc()],\n"
            "    TrackFit<trklet::N_LAYER, trklet::N_DISK>::BarrelStubWord barrelStubWords[trklet::N_LAYER][kMaxProc()],\n"
            "    TrackFit<trklet::N_LAYER, trklet::N_DISK>::DiskStubWord diskStubWords[trklet::N_DISK][kMaxProc()],\n"
            "    bool &done\n"
            ") {\n"
            "#pragma HLS inline recursive\n"
            "#pragma HLS array_partition variable=trackletParameters1 dim=1\n"
            "#pragma HLS array_partition variable=trackletParameters2 dim=1\n"
            "#pragma HLS array_partition variable=trackletParameters3 dim=1\n"
            "#pragma HLS array_partition variable=trackletParameters4 dim=1\n"
            "#pragma HLS array_partition variable=barrelFullMatches dim=1\n"
            "#pragma HLS array_partition variable=diskFullMatches dim=1\n"
        )
        for i in range(0, 4):
            for j in range(0, nTPARMem[i]):
                topFile.write("#pragma HLS resource variable=trackletParameters" + str(i + 1) + "[" + str(j) + "].get_mem() latency=2\n")
        for i in range(0, nBarrelFMMem):
            topFile.write("#pragma HLS resource variable=barrelFullMatches[" + str(i) + "].get_mem() latency=2\n")
        for i in range(0, nDiskFMMem):
            topFile.write("#pragma HLS resource variable=diskFullMatches[" + str(i) + "].get_mem() latency=2\n")
        topFile.write(
            "#pragma HLS interface register port=bx_o\n"
            "#pragma HLS array_partition variable=barrelStubWords dim=1\n"
            "#pragma HLS array_partition variable=diskStubWords dim=1\n"
            "#pragma HLS stream variable=trackWord depth=1 dim=1\n"
            "#pragma HLS stream variable=barrelStubWords depth=1 dim=2\n"
            "#pragma HLS stream variable=diskStubWords depth=1 dim=2\n"
            "#pragma HLS interface register port=done\n"
            "\n"
            "TB_" + seed + ": TrackBuilder<TF::" + seed + ", " + str(nFMBarrel) + ", " + str(nFMDisk) + ", " + str(nBarrelStubs) + ", " + str(nDiskStubs) + ", " + str(tparMask) + ">(\n"
            "    bx,\n"
            "    trackletParameters1,\n"
            "    trackletParameters2,\n"
            "    trackletParameters3,\n"
            "    trackletParameters4,\n"
            "    barrelFullMatches,\n"
            "    diskFullMatches,\n"
            "    bx_o,\n"
            "    trackWord,\n"
            "    barrelStubWords,\n"
            "    diskStubWords,\n"
            "    done\n"
            "  );\n"
            "}\n"
        )

    topHeaderFile.write(
        "\n"
        "#endif\n"
    )

    parameterFile.write(
        "\n"
        "\n#endif\n"
    )
